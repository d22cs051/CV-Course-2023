# -*- coding: utf-8 -*-
"""CV A2-A Q1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U0Y8AXs1LHH7W0QVYHIW6XW8uuZe8Cpd

# Find out which business brand is present in the scene

## Getting Data
"""

from pathlib import Path
file_id = "1x1RdxmjBvkRfBMSo7KJ9NE1w8HfxiZW5"
url = f"https://drive.google.com/uc?id={file_id}&export=download"
data_path = Path("data.zip")
if not data_path.is_file():
  print("INFO: Downloading files.")
  !wget -O "data.zip" {url}
else:  
  print("INFO: files Already exists.")

from pathlib import Path
data_path = Path("Problem-1")
if not data_path.is_dir():
  print("INFO: Files Not Exists extracting")
  !unzip -q "data.zip"
else:  
  print("INFO: files Already exists.")

"""## Applying SIFT with Brute Force KNN"""

import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt
from pathlib import Path

def sift_matching_bf_knn(img1:np.array,img2:np.array)->None:
  ### Inits ###
  # Initiate SIFT detector
  sift = cv.SIFT_create()
  # find the keypoints and descriptors with SIFT
  kp1, des1 = sift.detectAndCompute(img1,None)
  kp2, des2 = sift.detectAndCompute(img2,None)
  # BFMatcher with default params
  bf = cv.BFMatcher()
  matches = bf.knnMatch(des1,des2,k=2)
  # Apply ratio test
  bf = cv.BFMatcher()
  matches = bf.knnMatch(des1,des2,k=2)
  # Apply ratio test
  good = []
  for m,n in matches:
      if m.distance < 0.7*n.distance:
          good.append(m)

  ### Applying findHomography ###
  if len(good)>=MIN_MATCH_COUNT:
      src_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)
      dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)
      M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC,5.0)
      matchesMask = mask.ravel().tolist()
      h,w = img1.shape[:2]
      pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)
      dst = cv.perspectiveTransform(pts,M)
      img2 = cv.polylines(img2,[np.int32(dst)],True,(255,255,255),3, cv.LINE_AA)
  else:
      print( "Not enough matches are found - {}/{}".format(len(good), MIN_MATCH_COUNT) )
      matchesMask = None
    

  ### Ploting Matcheings and outline ###
  draw_params = dict(matchColor = (0,255,0), # draw matches in green color
                    singlePointColor = None,
                    matchesMask = matchesMask, # draw only inliers
                    flags = 2)
  img3 = cv.drawMatches(img1,kp1,img2,kp2,good,None,**draw_params)
  plt.figure(figsize=(12,8))
  if len(img3.shape)>2:
    plt.imshow(img3[:,:,::-1], 'gray')
  else:
    plt.imshow(img3, 'gray')
  plt.show()

images_path = Path("Problem-1/logo matching/Ex1")


MIN_MATCH_COUNT = 22
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'levis.jpg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  sift_matching_bf_knn(img1,img2)
  print("---------------------------------------")

images_path = Path("Problem-1/logo matching/Ex2")


MIN_MATCH_COUNT = 22
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'starbucks.jpeg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  sift_matching_bf_knn(img1,img2)
  print("---------------------------------------")

"""## Applying BRISK with Brute Force KNN"""

import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt
from pathlib import Path


def brisk_matching_bf_knn(img1,img2):
  ### Inits ###
  # Initiate BRISK detector
  sift = cv.BRISK_create()
  # find the keypoints and descriptors with SIFT
  kp1, des1 = sift.detectAndCompute(img1,None)
  kp2, des2 = sift.detectAndCompute(img2,None)
  # BFMatcher with default params
  bf = cv.BFMatcher()
  matches = bf.knnMatch(des1,des2,k=2)
  # Apply ratio test
  good = []
  for m,n in matches:
      if m.distance < 0.7*n.distance:
          good.append(m)

  ### Applying findHomography ###
  if len(good)>=MIN_MATCH_COUNT:
      src_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)
      dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)
      M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC,5.0)
      matchesMask = mask.ravel().tolist()
      h,w = img1.shape[:2]
      pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)
      dst = cv.perspectiveTransform(pts,M)
      img2 = cv.polylines(img2,[np.int32(dst)],True,(255,255,255),3, cv.LINE_AA)
  else:
      print( "Not enough matches are found - {}/{}".format(len(good), MIN_MATCH_COUNT) )
      matchesMask = None
    

  ### Ploting Matcheings and outline ###
  draw_params = dict(matchColor = (0,255,0), # draw matches in green color
                    singlePointColor = None,
                    matchesMask = matchesMask, # draw only inliers
                    flags = 2)
  img3 = cv.drawMatches(img1,kp1,img2,kp2,good,None,**draw_params)
  plt.figure(figsize=(12,8))
  if len(img3.shape)>2:
    plt.imshow(img3[:,:,::-1], 'gray')
  else:
    plt.imshow(img3, 'gray')
  plt.show()

from pathlib import Path
images_path = Path("Problem-1/logo matching/Ex1")


MIN_MATCH_COUNT = 7
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'levis.jpg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  brisk_matching_bf_knn(img1,img2)
  print("---------------------------------------")

images_path = Path("Problem-1/logo matching/Ex2")


MIN_MATCH_COUNT = 7
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'starbucks.jpeg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  brisk_matching_bf_knn(img1,img2)
  print("---------------------------------------")

"""## Applying KAZE with Brute Force KNN"""

import numpy as np
import cv2 as cv
from matplotlib import pyplot as plt
from pathlib import Path


def kaze_matching_bf_knn(img1,img2):
  ######
  # Initiate KAZE detector
  kaze = cv.KAZE_create()
  # find the keypoints and descriptors with kaze
  kp1, des1 = kaze.detectAndCompute(img1,None)
  kp2, des2 = kaze.detectAndCompute(img2,None)
  # BFMatcher with default params
  bf = cv.BFMatcher()
  matches = bf.knnMatch(des1,des2,k=2)
  # Apply ratio test
  good = []
  for m,n in matches:
      if m.distance < 0.7*n.distance:
          good.append(m)

  ### Applying findHomography ###
  if len(good)>=MIN_MATCH_COUNT:
      src_pts = np.float32([ kp1[m.queryIdx].pt for m in good ]).reshape(-1,1,2)
      dst_pts = np.float32([ kp2[m.trainIdx].pt for m in good ]).reshape(-1,1,2)
      M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC,5.0)
      matchesMask = mask.ravel().tolist()
      h,w = img1.shape[:2]
      pts = np.float32([ [0,0],[0,h-1],[w-1,h-1],[w-1,0] ]).reshape(-1,1,2)
      dst = cv.perspectiveTransform(pts,M)
      img2 = cv.polylines(img2,[np.int32(dst)],True,(255,255,255),3, cv.LINE_AA)
  else:
      print( "Not enough matches are found - {}/{}".format(len(good), MIN_MATCH_COUNT) )
      matchesMask = None
    

  ### Ploting Matcheings and outline ###
  draw_params = dict(matchColor = (0,255,0), # draw matches in green color
                    singlePointColor = None,
                    matchesMask = matchesMask, # draw only inliers
                    flags = 2)
  img3 = cv.drawMatches(img1,kp1,img2,kp2,good,None,**draw_params)
  plt.figure(figsize=(12,8))
  if len(img3.shape)>2:
    plt.imshow(img3[:,:,::-1], 'gray')
  else:
    plt.imshow(img3, 'gray')
  plt.show()

from pathlib import Path
images_path = Path("Problem-1/logo matching/Ex1")


MIN_MATCH_COUNT = 25
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'levis.jpg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  kaze_matching_bf_knn(img1,img2)
  print("---------------------------------------")

images_path = Path("Problem-1/logo matching/Ex2")


MIN_MATCH_COUNT = 20
src_images_path = list(map(str,images_path.glob('logos/*.jpg')))

for img1_path in src_images_path:
  img1 = cv.imread(img1_path) # trainImage
  # plt.imshow(img1[:,:,::-1],cmap="gray")
  # plt.show()
  img2 = cv.imread(str(images_path/'starbucks.jpeg'))          # queryImage
  # plt.imshow(img2[:,:,::-1],cmap="gray")
  # plt.show()
  kaze_matching_bf_knn(img1,img2)
  print("---------------------------------------")